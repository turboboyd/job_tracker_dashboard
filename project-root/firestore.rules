rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------
    // Helpers
    // ----------------------------
    function signedIn() {
      return request.auth != null;
    }

    function uid() {
      return request.auth.uid;
    }

    function isSelf(userId) {
      return signedIn() && uid() == userId;
    }

    function isNonEmptyString(v) {
      return (v is string) && (v.size() > 0);
    }

    function isValidLoop(data) {
      return data.keys().hasOnly([
        "name",
        "titles",
        "location",
        "radiusKm",
        "remoteMode",
        "platforms",
        "filters",
        "createdAt",
        "updatedAt",
        "createdAtTs",
        "updatedAtTs"
      ])
      && isNonEmptyString(data.name)
      && (data.titles is list)
      && (data.location is string)
      && (data.radiusKm is number)
      && (data.remoteMode is string)
      && (data.platforms is list)
      && (!("filters" in data) || data.filters is map)
      && (!("createdAt" in data) || data.createdAt is string)
      && (!("updatedAt" in data) || data.updatedAt is string)
      && (data.createdAtTs is timestamp)
      && (data.updatedAtTs is timestamp);
    }

    function loopCreatedAtUnchanged() {
      return request.resource.data.createdAtTs == resource.data.createdAtTs;
    }

    function isValidLoopMatch(data) {
      return data.keys().hasOnly([
        "loopId",
        "title",
        "company",
        "location",
        "platform",
        "url",
        "description",
        "status",
        "matchedAt",
        "createdAt",
        "updatedAt",
        "createdAtTs",
        "updatedAtTs"
      ])
      && isNonEmptyString(data.loopId)
      && isNonEmptyString(data.title)
      && (data.company is string)
      && (data.location is string)
      && (data.platform is string)
      && (data.url is string)
      && (data.description is string)
      && (data.status is string)
      && (data.matchedAt is string)
      && (data.createdAt is string)
      && (data.updatedAt is string)
      && (data.createdAtTs is timestamp)
      && (data.updatedAtTs is timestamp);
    }

    function matchCreatedAtUnchanged() {
      return request.resource.data.createdAtTs == resource.data.createdAtTs;
    }

    // ----------------------------
    // Favorites: users/{uid}/private/resourcesFavorites
    // ----------------------------
    function isValidResourceFavorites(data) {
      // We keep it strict on allowed fields + list size,
      // but avoid .all() to prevent parser/linter issues.
      return data.keys().hasOnly(["ids", "updatedAt", "userId"])
        && ("ids" in data)
        && (data.ids is list)
        && (data.ids.size() <= 500)
        && (!("userId" in data) || ((data.userId is string) && (data.userId == uid())))
        && (!("updatedAt" in data) || (data.updatedAt is timestamp));
    }

    function favoritesUserIdUnchanged() {
      return !("userId" in resource.data)
        || request.resource.data.userId == resource.data.userId;
    }

    match /users/{userId}/private/resourcesFavorites {
      allow read: if isSelf(userId);

      allow create: if isSelf(userId) && isValidResourceFavorites(request.resource.data);

      allow update: if isSelf(userId)
        && isValidResourceFavorites(request.resource.data)
        && favoritesUserIdUnchanged();

      allow delete: if isSelf(userId);
    }

    // ----------------------------
    // Private per-user data
    // ----------------------------

    // Root user doc (users/{uid}) â€” required for aggregation calls like getCountFromServer()
    match /users/{userId} {
      allow read: if isSelf(userId);
      allow write: if false;
    }

    match /users/{userId}/loops/{loopId} {
      allow read: if isSelf(userId);

      allow create: if isSelf(userId) && isValidLoop(request.resource.data);

      allow update: if isSelf(userId)
        && isValidLoop(request.resource.data)
        && loopCreatedAtUnchanged();

      allow delete: if isSelf(userId);
    }

    match /users/{userId}/loopMatches/{matchId} {
      allow read: if isSelf(userId);

      allow create: if isSelf(userId) && isValidLoopMatch(request.resource.data);

      allow update: if isSelf(userId)
        && isValidLoopMatch(request.resource.data)
        && matchCreatedAtUnchanged();

      allow delete: if isSelf(userId);
    }

    // ----------------------------
    // User settings: users/{uid}/private/settings
    // ----------------------------
    match /users/{userId}/private/settings {
      allow read: if isSelf(userId);

      allow create: if isSelf(userId) && isValidSettings(request.resource.data);

      allow update: if isSelf(userId)
        && isValidSettings(request.resource.data)
        && settingsUserIdUnchanged();

      allow delete: if false;
    }

    function settingsUserIdUnchanged() {
      return !("userId" in resource.data)
        || request.resource.data.userId == resource.data.userId;
    }

    function isValidSettings(data) {
      return data.keys().hasOnly([
        "timeZone",
        "dateFormat",
        "uiLanguage",
        "notifications",
        "updatedAt",
        "userId"
      ])
      && (!("userId" in data) || (data.userId is string && data.userId == uid()))
      && (!("timeZone" in data) || (data.timeZone is string && data.timeZone.size() >= 1 && data.timeZone.size() <= 64))
      && (!("dateFormat" in data) || data.dateFormat in ["DD.MM.YYYY", "MM/DD/YYYY", "YYYY-MM-DD"])
      && (!("uiLanguage" in data) || data.uiLanguage in ["en", "de", "ru"])
      && (!("notifications" in data) || isValidNotifications(data.notifications))
      && (!("updatedAt" in data) || data.updatedAt is timestamp);
    }

    function isValidNotifications(n) {
      return n is map
        && n.keys().hasOnly(["emailEnabled", "inAppEnabled"])
        && (!("emailEnabled" in n) || n.emailEnabled is bool)
        && (!("inAppEnabled" in n) || n.inAppEnabled is bool);
    }

    // ----------------------------
    // User outcome: users/{uid}/private/outcome
    // ----------------------------
    match /users/{userId}/private/outcome {
      allow read: if isSelf(userId);

      allow create: if isSelf(userId) && isValidOutcome(request.resource.data);

      allow update: if isSelf(userId)
        && isValidOutcome(request.resource.data)
        && outcomeUserIdUnchanged();

      allow delete: if isSelf(userId);
    }

    function outcomeUserIdUnchanged() {
      return !("userId" in resource.data)
        || request.resource.data.userId == resource.data.userId;
    }

    function isValidOutcome(data) {
      return data.keys().hasOnly([
        "employmentStatus",
        "feedback",
        "updatedAt",
        "userId"
      ])
      && (!("userId" in data) || (data.userId is string && data.userId == uid()))
      && ("employmentStatus" in data)
      && (data.employmentStatus in ["waiting", "hired"])
      && (!("feedback" in data) || data.feedback in ["positive", "neutral", "negative"])
      && (!("updatedAt" in data) || data.updatedAt is timestamp);
    }

    // ----------------------------
    // Public aggregated stats
    // ----------------------------
    match /publicStats/{docId} {
      allow read: if true;
      allow write: if false;
    }
  }
}